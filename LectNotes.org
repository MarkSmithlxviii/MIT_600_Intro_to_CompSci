# Author Mark Smith

Notes taken while listening to the [[http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-00sc-introduction-to-computer-science-and-programming-spring-2011/index.htm][MIT 600]] spring 2011 online lecture videos.

* Lecture one
** Aim of the course
We want to be able to map a  problem to a computational framework.
We will be able to write small and medium sized problems.
How well can we solve problems.
Studies indicate that students learn more if they take their own notes.
Programing is fun! 
Learn computational problem solving
** What is computation
There are basically two types of knowledge
 - Declerative - statements of fact eg. "A good health care plan improves the
   quality of medical care while saving money" or "y is the sqrt of x iff y*y
   =x" this does not tell us how to find sqrt x however it does tell us if
   a guess is correct.
 - Imperitive tells us how to acomplish something.  eg recipie for chocolate
   cake.  eg approximaton of sqrt guess(new) = ( guess(old) + x/g(old))/2
   this algorythm (a description of how to perform a computation) has 
   converged when g*g is close enough to x.
     - The algorythm contains a set of instructions (steps to be executed)
     - flow of control, order to execute the steps, and a return to g(new)
     - termination condition
How do we make a machine follow the algorithim?  Build a machine to perform
only this task, a fixed program computer, eg Turing's bombs.
These are limited useful computer.
The stored program computer, changed everything.  The instructions are no 
different than the data. The machine became infinitely flexible.  Programs
could produce programs.  This lead to the computer itself being considered 
as a program, namely computer as interpreter.
An interpreter can execute any legal set of instructions.
Most computers have only a very small number of built in instructions.
Turing showed that 6 primitive instructions were all that was needed.
Progaming language provides a set of primitive instructions and set of 
primitive flow of control and the combining mechanisms.

The computer will always do exactly what it is told.

A programing language has:
  - Syntax which sequences of symbols and characters make a well formed string
  - Static semantics which well formed strings have meaning eg Susan is 
    building is syntactially well formed, the words are in the right order
    but not very meaningful
  - Semantics the meaning of the sting that passes both tests above.

In natural language meaning is ambigous, a well formed statement in a
programming laguage has exactly one meaning.

What happens when we write a progam that doesn't do what we wanted it to do?
- Crash in a properly designed computing system one crash will not affect 
the rest of the program
- It may not stop running.  If we don't know how long the program should run
this will be hard to judge.  Infinite loop
- may run to completion and give the wrong answer.
In Ascending order of badness.
Some languages give alot of help for these problems

Lecture done
** Answers to the questions on the course web page
*** What is the difference between declaritive and imperitive knowledge
Declatitive deals with declarations - facts observations 'I like chocolate cake.  
while imperitive is the knowledge of how.  How to bake the cake how to calculate sqrt(x)
*** What is the advantage of a stored program computer
A stored program computer is flexible.  It can be used to solve any problem that 
a fixed program computer can solve however it is not limited to only one type
of problem.
*** What are syntax, static semantics and semantics of a language
Same as natural language syntax is the grammer, what sequence of symbols
constitutes a well formed string/sentence.  
Static semantics defines which of the well formed strings have meaning.  
Semantics are the meanings of the strings that pass the above tests.
*** What kinds of errors can occur in a program
The program can crash, terminate without completing and without returning an
answer.
The program can loop continously never returning a result.
The program can finish and return an incorrect answer. 
* Lecture 2
** IDE 
integrated development environment
includes a specialized text editor
syntax highlighting
python shell
debugger most programers rely on print statements for debugging
 - when using print statements try and print value and type as type is not
   necessarily clear from value alone
** objects
everything in python is an object.
even the code is an object
each object has a type.  inbuilt function type that will return the object type
two basic types of object scalar and non scalar
scalars are non divisible / atom
 - integer 
 - float a computer approximation of the real numbers
 - boolean TRUE/FALSE
 - none is nonetype used as a temp placeholder
 - does not have char (character)object type however strings can be of length 1
for every type there is a literal eg 3 is a literal of the integer between 
2 and 4, 'ab' is a string literal.
** expressions
an expression is a sequence of operands(objects) and operators
some of the operators are overloaded the meaning will be dependant on the type
of operands eg 'a'+'b' + is overloaded and means concatinate
** programs
A program is a sequence of commands that tell the computer to do something
*** General
Indentation has meaning python is unusual in this way.  Programmers use 
indentation to make the program readable.
Programs are meant to be read not just executed, the structure of the program
should reflect the semantics of the program.
Assignment binds the name to the object
*** Types of programs
 - a straight line program runs from start to finish in a straight line (boring)
 - most recipies have some sort of looping or test
   eg cook the meat until it is 70 C.
 - The most primitive test is a Conditional statement using if else elif
   - can be nested one condition within another
 - conditional statements introduce branchs into the program. but the program
   still runs from start to finish there are multiple possible paths to a 
   common end point.
 - Looping constructs, Turing Complete  Introduces iteration statements can 
   be executed more than once
**** Time to execute a program
A straight line program execution time depends on the number of statements.
A branching program will depend on the length of the longest set of branches.
A branching program is only slightly more complicated than a straight line
program

Not much can be accomplished with these types of programs.  We can only type 
so many lines of code in our lifetimes.  A way to evaluate the 'goodness' of 
a program is that the execution time is proportional to the input rather than 
to the number of lines of code in the program.

Looping programs (iteration) the program can reexecute statements depending on 
the conditional statements execution times are dependant on the size of the 
input data rather than the size of the program.

** variables
a name for an object (python)
assignment statement binds a name to an object
** comments
Make the program easier to read
use comments to explain your thinking
what is the algorythm that has been used 
not to explain the language
answer the question what was I thinking when re-reading the script in 
2 years from now.
** Questions on the website.
*** What is a type
Int Float String, Type is a property of an object.
*** what is an expresion
it is a combination of operands and operators that can be interperted into a 
value
*** What is type conversion
Changing an object from one type to another.
*** what is a keyword
A protected string that cannot be used as the name of an object eg float or if
*** What is the difference between a straight line program and a branching Program
a straight line program runs from start to finish along the same path every time
while a branching program will change paths depending on conditional statements
*** What is a conditional
if and else,  it is a test to see if a block of code should be run. 
* recitation 1 (after lecture 2)

** Computation
Take a real problem and break it down into small managable pieces
actual code is non diciferable 10110101001101001.
a programing language can be non readable or it can be easily readable
syntax and static semantics are realatively easy for a compiler/interperater 
to check.
semantics not so much eg 1/0 is leagal and conforms to static semantics however
it is wrong
Python is a general purpose language 
interperted
A program is a sequence of expresions - operands and operators.
everything in Python is an object all objects have types, int, float, str etc.
Python determines the type at assignment depending on the input types. 
While is used if we dont know how long the loop needs to run
For is used if we know exacly ow long to run the loop.

* Lecture 3: Problem Solving
** Decramenting functions.
The cube root program will terminate for all integer values of x.  This is 
because a decramenting function has been used (as a notion in the authors
head).  every time we write a loop think of decrementing functions.  

python

#Find the cube root of a perfect cube
x = int(raw_input('Enter an integer: '))
ans = 0
while ans*ans*ans < abs(x):
    ans = ans + 1
    #print 'current guess =', ans
if ans*ans*ans != abs(x):
    print x, 'is not a perfect cube'
else:
    if x < 0:
        ans = -ans
    print 'Cube root of ' + str(x) + ' is ' + str(ans)

*** Properties of a decrimenting function
it is only in the mind of the programmer but it is used to think 
about the program.
 - map a set of program variables to an integer
 - when the loop is entered it takes a non negative value
 - When its value gets to be less than or equal to zero the loop terminates
 - decreased at each step of the loop
the decrimenting function in the cube root program is
abs(x)-ans^3 this satisfies the conditions and will terminate.

This is an example of guess and check. called exhaustive enumeration. 
Enumerating all possible answers.  if we get to the end condition and 
have not found a perfect cube root then we know that the number is not a 
perfect cube.  This is a brute force process.  This is a completely acceptable 
way to solve problems as computers are sooooo fast.  
Stopped at 15 minutes


* useful commands
raw_input (2.x) all input is of type str even for example 3.2
bothraw_input and input (3.x) requires input to continue running the script. 
The input data is interperted as a string.
This is changed to commit a new file again just for a new commit.
What is this the 6th time making an insignificant change?
This is one time more than the last time.
